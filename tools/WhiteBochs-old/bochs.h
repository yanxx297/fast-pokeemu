/////////////////////////////////////////////////////////////////////////
// $Id: bochs.h,v 1.253 2010/04/13 17:56:50 sshwarts Exp $
/////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2001-2009  The Bochs Project
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA B 02110-1301 USA

//
// bochs.h is the master header file for all C++ code.  It includes all
// the system header files needed by bochs, and also includes all the bochs
// C++ header files.  Because bochs.h and the files that it includes has
// structure and class definitions, it cannot be called from C code.
//

#ifndef BX_BOCHS_H
#  define BX_BOCHS_H 1

#include "config.h"      /* generated by configure script from config.h.in */

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <errno.h>

#include <time.h>
#include <ctype.h>
#include <string.h>
#include <fcntl.h>
#include <limits.h>

#include "osdep.h"       /* platform dependent includes and defines */

// BX_SHARE_PATH should be defined by the makefile.  If not, give it
// a value of NULL to avoid compile problems.
#ifndef BX_SHARE_PATH
#define BX_SHARE_PATH NULL
#endif

// =-=-=-=-=-=-=- Normal optimized use -=-=-=-=-=-=-=-=-=-=-=-=-=-=
// some pc_systems functions just redirect to the IO devices so optimize
// by eliminating call here
//
// #define BX_INP(addr, len)        bx_pc_system.inp(addr, len)
// #define BX_OUTP(addr, val, len)  bx_pc_system.outp(addr, val, len)
#define BX_INP(addr, len)           0
#define BX_OUTP(addr, val, len)     1
#define BX_TICK1()                  
#define BX_TICKN(n)                 
#define BX_INTR                     
#define BX_SET_INTR(b)              
#define BX_CPU_C                    bx_cpu_c
#define BX_MEM_C                    bx_mem_c
#define BX_HRQ

#define BX_CPU(x)                   (&bx_cpu)
#define BX_MEM(x)                   (&bx_mem)

#define BX_SET_ENABLE_A20(enabled)  
#define BX_GET_ENABLE_A20()         
#define A20ADDR(x)                

#define BX_TICK1_IF_SINGLE_PROCESSOR()  BX_TICK1()
#define BX_TICKN_IF_SINGLE_PROCESSOR(n) BX_TICKN(n)

#define MAGIC_LOGNUM 0x12345678

#define BX_INFO(x)
#define BX_DEBUG(x)
#define BX_ERROR(x)
#define BX_PANIC(x) 
#define BX_PASS(x) 
#define BX_ASSERT(x)

#ifndef UNUSED
#  define UNUSED(x) ((void)x)
#endif

#if BX_SUPPORT_X86_64
#define FMT_ADDRX FMT_ADDRX64
#else
#define FMT_ADDRX FMT_ADDRX32
#endif

#if BX_PHY_ADDRESS_LONG
  #define FMT_PHY_ADDRX FMT_ADDRX64
#else
  #define FMT_PHY_ADDRX FMT_ADDRX32
#endif

#define FMT_LIN_ADDRX FMT_ADDRX

// memory access type (read/write/execute/rw)
#define BX_READ         0
#define BX_WRITE        1
#define BX_EXECUTE      2
#define BX_RW           3

// to be used in concatenation with BX_READ/BX_WRITE/BX_EXECUTE/BX_RW
#define BX_PDPTR0_ACCESS          0x010
#define BX_PDPTR1_ACCESS          0x020
#define BX_PDPTR2_ACCESS          0x030
#define BX_PDPTR3_ACCESS          0x040
#define BX_PTE_ACCESS             0x050
#define BX_PDE_ACCESS             0x060
#define BX_PDPTE_ACCESS           0x070
#define BX_PML4E_ACCESS           0x080
#define BX_EPT_PTE_ACCESS         0x090
#define BX_EPT_PDE_ACCESS         0x0a0
#define BX_EPT_PDPTE_ACCESS       0x0b0
#define BX_EPT_PML4E_ACCESS       0x0c0
#define BX_VMCS_ACCESS            0x0d0
#define BX_VMX_MSR_BITMAP_ACCESS  0x0e0
#define BX_VMX_IO_BITMAP_ACCESS   0x0f0
#define BX_VMX_LOAD_MSR_ACCESS    0x100
#define BX_VMX_STORE_MSR_ACCESS   0x110
#define BX_VMX_VTPR_ACCESS        0x120
#define BX_SMRAM_ACCESS           0x130

// types of reset
#define BX_RESET_SOFTWARE 10
#define BX_RESET_HARDWARE 11

#include "memory/memory.h"

// These are some convenience macros which abstract out accesses between
// a variable in native byte ordering to/from guest (x86) memory, which is
// always in little endian format.  You must deal with alignment (if your
// system cares) and endian rearranging.  Don't assume anything.  You could
// put some platform specific asm() statements here, to make use of native
// instructions to help perform these operations more efficiently than C++.

#ifdef BX_LITTLE_ENDIAN

#define WriteHostWordToLittleEndian(hostPtr,  nativeVar16) \
    *((Bit16u*)(hostPtr)) = (nativeVar16)
#define WriteHostDWordToLittleEndian(hostPtr, nativeVar32) \
    *((Bit32u*)(hostPtr)) = (nativeVar32)
#define WriteHostQWordToLittleEndian(hostPtr, nativeVar64) \
    *((Bit64u*)(hostPtr)) = (nativeVar64)

#define ReadHostWordFromLittleEndian(hostPtr,  nativeVar16) \
    (nativeVar16) = *((Bit16u*)(hostPtr))
#define ReadHostDWordFromLittleEndian(hostPtr, nativeVar32) \
    (nativeVar32) = *((Bit32u*)(hostPtr))
#define ReadHostQWordFromLittleEndian(hostPtr, nativeVar64) \
    (nativeVar64) = *((Bit64u*)(hostPtr))

#define CopyHostWordLittleEndian(hostAddrDst,  hostAddrSrc)  \
    (* (Bit16u *)(hostAddrDst)) = (* (Bit16u *)(hostAddrSrc));
#define CopyHostDWordLittleEndian(hostAddrDst,  hostAddrSrc) \
    (* (Bit32u *)(hostAddrDst)) = (* (Bit32u *)(hostAddrSrc));
#define CopyHostQWordLittleEndian(hostAddrDst,  hostAddrSrc) \
    (* (Bit64u *)(hostAddrDst)) = (* (Bit64u *)(hostAddrSrc));

#else

#define WriteHostWordToLittleEndian(hostPtr,  nativeVar16) { \
    ((Bit8u *)(hostPtr))[0] = (Bit8u)  (nativeVar16);        \
    ((Bit8u *)(hostPtr))[1] = (Bit8u) ((nativeVar16)>>8);    \
}
#define WriteHostDWordToLittleEndian(hostPtr, nativeVar32) { \
    ((Bit8u *)(hostPtr))[0] = (Bit8u)  (nativeVar32);        \
    ((Bit8u *)(hostPtr))[1] = (Bit8u) ((nativeVar32)>>8);    \
    ((Bit8u *)(hostPtr))[2] = (Bit8u) ((nativeVar32)>>16);   \
    ((Bit8u *)(hostPtr))[3] = (Bit8u) ((nativeVar32)>>24);   \
}
#define WriteHostQWordToLittleEndian(hostPtr, nativeVar64) { \
    ((Bit8u *)(hostPtr))[0] = (Bit8u)  (nativeVar64);        \
    ((Bit8u *)(hostPtr))[1] = (Bit8u) ((nativeVar64)>>8);    \
    ((Bit8u *)(hostPtr))[2] = (Bit8u) ((nativeVar64)>>16);   \
    ((Bit8u *)(hostPtr))[3] = (Bit8u) ((nativeVar64)>>24);   \
    ((Bit8u *)(hostPtr))[4] = (Bit8u) ((nativeVar64)>>32);   \
    ((Bit8u *)(hostPtr))[5] = (Bit8u) ((nativeVar64)>>40);   \
    ((Bit8u *)(hostPtr))[6] = (Bit8u) ((nativeVar64)>>48);   \
    ((Bit8u *)(hostPtr))[7] = (Bit8u) ((nativeVar64)>>56);   \
}

#define ReadHostWordFromLittleEndian(hostPtr, nativeVar16) {   \
    (nativeVar16) =  ((Bit16u) ((Bit8u *)(hostPtr))[0]) |      \
                    (((Bit16u) ((Bit8u *)(hostPtr))[1])<<8) ;  \
}
#define ReadHostDWordFromLittleEndian(hostPtr, nativeVar32) {  \
    (nativeVar32) =  ((Bit32u) ((Bit8u *)(hostPtr))[0]) |      \
                    (((Bit32u) ((Bit8u *)(hostPtr))[1])<<8) |  \
                    (((Bit32u) ((Bit8u *)(hostPtr))[2])<<16) | \
                    (((Bit32u) ((Bit8u *)(hostPtr))[3])<<24);  \
}
#define ReadHostQWordFromLittleEndian(hostPtr, nativeVar64) {  \
    (nativeVar64) =  ((Bit64u) ((Bit8u *)(hostPtr))[0]) |      \
                    (((Bit64u) ((Bit8u *)(hostPtr))[1])<<8) |  \
                    (((Bit64u) ((Bit8u *)(hostPtr))[2])<<16) | \
                    (((Bit64u) ((Bit8u *)(hostPtr))[3])<<24) | \
                    (((Bit64u) ((Bit8u *)(hostPtr))[4])<<32) | \
                    (((Bit64u) ((Bit8u *)(hostPtr))[5])<<40) | \
                    (((Bit64u) ((Bit8u *)(hostPtr))[6])<<48) | \
                    (((Bit64u) ((Bit8u *)(hostPtr))[7])<<56);  \
}

#define CopyHostWordLittleEndian(hostAddrDst, hostAddrSrc) {   \
    ((Bit8u *)(hostAddrDst))[0] = ((Bit8u *)(hostAddrSrc))[0]; \
    ((Bit8u *)(hostAddrDst))[1] = ((Bit8u *)(hostAddrSrc))[1]; \
}
#define CopyHostDWordLittleEndian(hostAddrDst, hostAddrSrc) {  \
    ((Bit8u *)(hostAddrDst))[0] = ((Bit8u *)(hostAddrSrc))[0]; \
    ((Bit8u *)(hostAddrDst))[1] = ((Bit8u *)(hostAddrSrc))[1]; \
    ((Bit8u *)(hostAddrDst))[2] = ((Bit8u *)(hostAddrSrc))[2]; \
    ((Bit8u *)(hostAddrDst))[3] = ((Bit8u *)(hostAddrSrc))[3]; \
}
#define CopyHostQWordLittleEndian(hostAddrDst, hostAddrSrc) {  \
    ((Bit8u *)(hostAddrDst))[0] = ((Bit8u *)(hostAddrSrc))[0]; \
    ((Bit8u *)(hostAddrDst))[1] = ((Bit8u *)(hostAddrSrc))[1]; \
    ((Bit8u *)(hostAddrDst))[2] = ((Bit8u *)(hostAddrSrc))[2]; \
    ((Bit8u *)(hostAddrDst))[3] = ((Bit8u *)(hostAddrSrc))[3]; \
    ((Bit8u *)(hostAddrDst))[4] = ((Bit8u *)(hostAddrSrc))[4]; \
    ((Bit8u *)(hostAddrDst))[5] = ((Bit8u *)(hostAddrSrc))[5]; \
    ((Bit8u *)(hostAddrDst))[6] = ((Bit8u *)(hostAddrSrc))[6]; \
    ((Bit8u *)(hostAddrDst))[7] = ((Bit8u *)(hostAddrSrc))[7]; \
}

#endif

// Instrumentation (used to be in instrument/stubs/instrument.h)

/* initialization/deinitialization of instrumentalization */
#define BX_INSTR_INIT_ENV()
#define BX_INSTR_EXIT_ENV()

/* simulation init, shutdown, reset */
#define BX_INSTR_INITIALIZE(cpu_id)
#define BX_INSTR_EXIT(cpu_id)
#define BX_INSTR_RESET(cpu_id, type)
#define BX_INSTR_HLT(cpu_id)
#define BX_INSTR_MWAIT(cpu_id, addr, len, flags)
#define BX_INSTR_NEW_INSTRUCTION(cpu_id)

/* called from command line debugger */
#define BX_INSTR_DEBUG_PROMPT()
#define BX_INSTR_DEBUG_CMD(cmd)

/* branch resoultion */
#define BX_INSTR_CNEAR_BRANCH_TAKEN(cpu_id, new_eip)
#define BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(cpu_id)
#define BX_INSTR_UCNEAR_BRANCH(cpu_id, what, new_eip)
#define BX_INSTR_FAR_BRANCH(cpu_id, what, new_cs, new_eip)

/* decoding completed */
#define BX_INSTR_OPCODE(cpu_id, opcode, len, is32, is64)

/* exceptional case and interrupt */
#define BX_INSTR_EXCEPTION(cpu_id, vector, error_code)
#define BX_INSTR_INTERRUPT(cpu_id, vector)
#define BX_INSTR_HWINTERRUPT(cpu_id, vector, cs, eip)

/* TLB/CACHE control instruction executed */
#define BX_INSTR_CLFLUSH(cpu_id, laddr, paddr)
#define BX_INSTR_CACHE_CNTRL(cpu_id, what)
#define BX_INSTR_TLB_CNTRL(cpu_id, what, new_cr3)
#define BX_INSTR_PREFETCH_HINT(cpu_id, what, seg, offset)

/* execution */
#define BX_INSTR_BEFORE_EXECUTION(cpu_id, i)
#define BX_INSTR_AFTER_EXECUTION(cpu_id, i)
#define BX_INSTR_REPEAT_ITERATION(cpu_id, i)

/* memory access */
#define BX_INSTR_LIN_ACCESS(cpu_id, lin, phy, len, rw)

/* memory access */
#define BX_INSTR_MEM_DATA_ACCESS(cpu_id, seg, offset, len, rw)

/* called from memory object */
#define BX_INSTR_PHY_WRITE(cpu_id, addr, len)
#define BX_INSTR_PHY_READ(cpu_id, addr, len)

/* feedback from device units */
#define BX_INSTR_INP(addr, len)
#define BX_INSTR_INP2(addr, len, val)
#define BX_INSTR_OUTP(addr, len, val)

/* wrmsr callback */
#define BX_INSTR_WRMSR(cpu_id, addr, value)


#  define BX_DBG_ASYNC_INTR 1
#  define BX_DBG_ASYNC_DMA  1
#  define BX_DBG_DMA_REPORT(addr, len, what, val)                    /* empty */
#  define BX_DBG_IAC_REPORT(vector, irq)                             /* empty */
#  define BX_DBG_A20_REPORT(val)                                     /* empty */
#  define BX_DBG_IO_REPORT(port, size, op, val)                      /* empty */
#  define BX_DBG_LIN_MEMORY_ACCESS(cpu, lin, phy, len, pl, rw, data) /* empty */
#  define BX_DBG_PHY_MEMORY_ACCESS(cpu, phy, len, rw, data)          /* empty */



#endif  /* BX_BOCHS_H */
