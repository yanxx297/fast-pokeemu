Index: src/c_interface/c_interface.cpp
===================================================================
--- src/c_interface/c_interface.cpp	(revision 792)
+++ src/c_interface/c_interface.cpp	(working copy)
@@ -631,6 +631,16 @@
   delete c;
 }
 
+Expr * vc_getTrueCounterExampleFst(VC vc) {
+  Expr * es = (Expr *)(((stpstar)vc)->Ctr_Example->GetTrueCounterExampleFst());
+  return es;
+}
+
+Expr * vc_getTrueCounterExampleSnd(VC vc) {
+  Expr * es = (Expr *)(((stpstar)vc)->Ctr_Example->GetTrueCounterExampleSnd());
+  return es;
+}
+
 int vc_getBVLength(VC vc, Expr ex) {
   nodestar e = (nodestar)ex;
 
Index: src/c_interface/c_interface.h
===================================================================
--- src/c_interface/c_interface.h	(revision 792)
+++ src/c_interface/c_interface.h	(working copy)
@@ -334,6 +334,11 @@
   // Free the return value of vc_getWholeCounterExample
   void vc_deleteWholeCounterExample(WholeCounterExample cc);
 
+  // Counterexample as a Vine-style pair of ASTNode * arrays.
+  // Free these with free() when you're done with them.
+  Expr * vc_getTrueCounterExampleFst(VC vc);
+  Expr * vc_getTrueCounterExampleSnd(VC vc);
+
   //Kinds of Expr
   enum exprkind_t{
       UNDEFINED,
Index: src/absrefine_counterexample/AbsRefine_CounterExample.h
===================================================================
--- src/absrefine_counterexample/AbsRefine_CounterExample.h	(revision 792)
+++ src/absrefine_counterexample/AbsRefine_CounterExample.h	(working copy)
@@ -110,6 +110,11 @@
     //queries the counterexample, and returns the value corresponding
     //to e
     ASTNode GetCounterExample(bool t, const ASTNode& e);
+
+    // Yet another counterexample format, this one as used by the
+    // Vine project's old OCaml interface.
+    ASTNode **GetTrueCounterExampleFst(void);
+    ASTNode **GetTrueCounterExampleSnd(void);
       
     int CounterExampleSize(void) const
     {
Index: src/absrefine_counterexample/CounterExample.cpp
===================================================================
--- src/absrefine_counterexample/CounterExample.cpp	(revision 792)
+++ src/absrefine_counterexample/CounterExample.cpp	(working copy)
@@ -798,7 +798,80 @@
     //os << "\nEND OF COUNTEREXAMPLE" << endl;
   } //End of PrintCounterExample
 
+  // The following two functions produce a counter example data
+  // structure that should exactly match the text output, in the form
+  // of two malloced, null-terminated arrays of ASTNode pointers. For
+  // compatiblity with Vine's old OCaml interface, but we should
+  // figure out whether STP standard interfaces can now be used
+  // instead. -SMcC
+  ASTNode **AbsRefine_CounterExample::GetTrueCounterExampleFst() {
+    // Take a copy of the counterexample map, 'cause TermToConstTermUsingModel
+    // changes it. Which breaks the iterator otherwise.
+    const ASTNodeMap c(CounterExampleMap);
+    
+    ASTNode** trueCEFst = (ASTNode**)malloc(sizeof(ASTNode*) * c.size());
 
+    ASTNodeMap::const_iterator it = c.begin();
+    ASTNodeMap::const_iterator itend = c.end();
+    int i=0;
+    for (; it != itend; it++)
+      {
+        const ASTNode& f = it->first;
+        const ASTNode& se = it->second;
+
+        //skip over introduced variables
+        if (f.GetKind() == SYMBOL && 
+            (ArrayTransform->FoundIntroducedSymbolSet(f)))
+          {
+            continue;
+          }
+        if (f.GetKind() == SYMBOL     || 
+            (f.GetKind() == READ      && 
+             f[0].GetKind() == SYMBOL && 
+             f[1].GetKind() == BVCONST))
+          {
+	    trueCEFst[i++] = new ASTNode(f);
+          }
+      }
+    trueCEFst[i] = 0; // null terminate
+    return trueCEFst;
+  }
+
+  ASTNode **AbsRefine_CounterExample::GetTrueCounterExampleSnd() {
+    // Take a copy of the counterexample map, 'cause TermToConstTermUsingModel
+    // changes it. Which breaks the iterator otherwise.
+    const ASTNodeMap c(CounterExampleMap);
+    
+    ASTNode** trueCESnd = (ASTNode**)malloc(sizeof(ASTNode*) * c.size());
+
+    ASTNodeMap::const_iterator it = c.begin();
+    ASTNodeMap::const_iterator itend = c.end();
+    int i=0;
+    for (; it != itend; it++)
+      {
+        const ASTNode& f = it->first;
+        const ASTNode& se = it->second;
+
+	assert(ARRAY_TYPE != se.GetType());
+
+        //skip over introduced variables
+        if (f.GetKind() == SYMBOL && 
+            (ArrayTransform->FoundIntroducedSymbolSet(f)))
+          {
+            continue;
+          }
+        if (f.GetKind() == SYMBOL     || 
+            (f.GetKind() == READ      && 
+             f[0].GetKind() == SYMBOL && 
+             f[1].GetKind() == BVCONST))
+          {
+	    trueCESnd[i++] = new ASTNode(se);
+          }
+      }
+    trueCESnd[i] = 0; // null terminate
+    return trueCESnd;
+  }
+
   /* iterate through the CounterExampleMap data structure and print it
    * to stdout. this function prints only the declared array variables
    * IN the ORDER in which they were declared. It also assumes that
