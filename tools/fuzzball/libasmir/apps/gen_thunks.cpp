#include "irtoir.h"
#include "exp.h"
#include "stmt.h"
#include <assert.h>
#include <iostream>
using namespace std;

typedef vector<Stmt *> Mod_Func_0 (void);
typedef vector<Stmt *> Mod_Func_2 (reg_t, Exp *, Exp *);
typedef vector<Stmt *> Mod_Func_3 (reg_t, Exp *, Exp *, Exp *);

void gen_thunk(string name, int argnum, Mod_Func_0 *mod_eflags_func, 
               reg_t type)
{
  cout << "void " << name << "()" << endl;
  cout << "{" << endl;

  Exp *DEP1 = new Temp(REG_32, "R_CC_DEP1");
  Exp *DEP2 = new Temp(REG_32, "R_CC_DEP2");
  Exp *NDEP = new Temp(REG_32, "R_CC_NDEP");

  vector<Stmt*> mods;

  if (argnum == 2) {
    Mod_Func_2 *mod_func = (Mod_Func_2 *)mod_eflags_func;
    mods = mod_func(type, DEP1, DEP2);
  } else if (argnum == 3) {
    Mod_Func_3 *mod_func = (Mod_Func_3 *)mod_eflags_func;
    mods = mod_func(type, DEP1, DEP2, NDEP);
  } else
    assert(0);

  for(vector<Stmt*>::iterator
        i=mods.begin(); i!=mods.end(); i++) {
    cout << (*i)->tostring() << endl;
  }

  cout << "return;" << endl;
  cout << "}" << endl;
}

#define gt(name, argnum, helper) \
gen_thunk("X86G_CC_OP_" #name "B_thunk", argnum, (Mod_Func_0*)mod_eflags_##helper, REG_8); \
gen_thunk("X86G_CC_OP_" #name "W_thunk", argnum, (Mod_Func_0*)mod_eflags_##helper, REG_16); \
gen_thunk("X86G_CC_OP_" #name "L_thunk", argnum, (Mod_Func_0*)mod_eflags_##helper, REG_32); 

void cc_op_chk(int cc_op, string cc_op_s)
{
  // leaks like mad. doesn't matter.

  Exp *cond = _ex_eq(new Temp(REG_32, "R_CC_OP"), 
                     ex_const(REG_32, cc_op));
  string tname = cc_op_s + "_t";
  string fname = cc_op_s + "_f";
  string fnname = cc_op_s + "_thunk";
  cout << (new CJmp(cond, ex_name(tname), ex_name(fname)))->tostring()
       << endl;
  cout << (new Label(tname))->tostring() << endl;
  vector<Exp*> params;
  cout << (new Call(NULL, fnname, params))->tostring() << endl;
  cout << "return;" << endl;
  cout << (new Label(fname))->tostring() << endl;
}

#define CC_OP_CHK(op) cc_op_chk(op, #op)

#define CC_OP_CHK3(op) \
CC_OP_CHK(op##B); \
CC_OP_CHK(op##W); \
CC_OP_CHK(op##L)

void gen_x86g_calculate_eflags_all() 
{
  cout << "void x86g_calculate_eflags_all()" << endl;
  cout << "{" << endl;

  CC_OP_CHK(X86G_CC_OP_COPY);

  CC_OP_CHK3(X86G_CC_OP_ADD);
  CC_OP_CHK3(X86G_CC_OP_SUB);
  CC_OP_CHK3(X86G_CC_OP_ADC);
  CC_OP_CHK3(X86G_CC_OP_SBB);
  CC_OP_CHK3(X86G_CC_OP_LOGIC);
  CC_OP_CHK3(X86G_CC_OP_INC);
  CC_OP_CHK3(X86G_CC_OP_DEC);
  CC_OP_CHK3(X86G_CC_OP_SHL);
  CC_OP_CHK3(X86G_CC_OP_SHR);
  CC_OP_CHK3(X86G_CC_OP_ROL);
  CC_OP_CHK3(X86G_CC_OP_ROR);
  CC_OP_CHK3(X86G_CC_OP_UMUL);
  CC_OP_CHK3(X86G_CC_OP_SMUL);
  cout << (new Special("BAD_CC_OP"))->tostring() << endl;
  cout << "return;" << endl;
  cout << "}" << endl;
}

void gen_x86g_calculate_eflags_c() 
{
  cout << "void x86g_calculate_eflags_c()" << endl;
  cout << "{" << endl;
  vector<Exp*> params;
  cout << (new Call(NULL, "x86g_calculate_eflags_all", params))->tostring()
       << endl;
  cout << "return;" << endl;
  cout << "}" << endl;
}

int main(int argc, char **argv)
{
  cout << (new Comment("Automatically generated by " 
                       "libasmir/apps/gen_thunks"))->tostring() << endl;
  cout << (new Comment("do not edit manually!"))->tostring() << endl;
  cout << "#include \"reg_decls.ir\"" << endl;

  gen_thunk("X86G_CC_OP_COPY_thunk", 2, (Mod_Func_0*)mod_eflags_copy, REG_32);

  gt(ADD, 2, add);
  gt(SUB, 2, sub);
  gt(ADC, 3, adc);
  gt(SBB, 3, sbb);
  gt(LOGIC, 2, logic);
  gt(INC, 3, inc);
  gt(DEC, 3, dec);
  gt(SHL, 2, shl);
  gt(SHR, 2, shr);
  gt(ROL, 3, rol);
  gt(ROR, 3, ror);
  gt(UMUL, 2, umul);
  gt(SMUL, 2, smul);

  gen_x86g_calculate_eflags_all();
  gen_x86g_calculate_eflags_c();
}
