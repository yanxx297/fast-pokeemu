(**
   An interface to program state files generated by Tracecap. 
   
   @author Juan Caballero, Zhenkai Liang
*)

(** Raised for state files with an unknown version number in the header *)
exception Unknown_state_version

(** Raised for get_(byte|short|word|long) methods if full range not in 
  state file *)
exception Incomplete_value

(** Raised when requesting registers from state file without register info *)
exception Registers_unavailable

(** Flags *)
type state_flags_t = {
  includes_registers : bool;
  includes_kernel_mem : bool;
  includes_taint : bool;
  virtual_addresses : bool;
  process_snapshot : bool;
}

(** The state file header *)
type state_header_t = {
  state_version : int;
  state_word_size : int;
  state_flags : state_flags_t;
}

(* Taint region *)
type taint_region_t = {
  tr_start_addr : Libasmir.address_t;
  tr_taintmask : int64;
  tr_pos : int64;
}


(** Registers in a state file *)
type userRegs = {
  eax : int32;
  ebx : int32;
  ecx : int32;
  edx : int32;
  esi : int32;
  edi : int32;
  ebp : int32;
  esp : int32;
  eip : int32;
  eflags : int32;
  xcs : int32;
  xds : int32;
  xes : int32;
  xfs : int32;
  xgs : int32;
  xss : int32;
}

(** Class for memory blocks
    A memory block is a of addresses in a state file (usually a page).
    (both first and last addresses belong to the block 
*)
class virtual memblock :
object
  (** Get start address for memblock *)
  method virtual first : Int64.t

  (** Get end address for memblock *)
  method virtual last : Int64.t

  (** Get size of memblock *)
  method virtual size : int

  (** Get file offset for beginning of memory values *)
  method virtual file_pos : Int64.t

  (** Get list of taint regions for the memblock *)
  method virtual taint_l : taint_region_t list

  (** Number of bytes in taint block size *)
  method virtual taint_block_size : int

  (** Number of taint blocks in memblock *)
  method virtual num_taint_blocks : int

  (** Number of tainted bytes in memblock *)
  method virtual num_tainted_bytes : int

  (** Unserialize a memblock from file *)
  method virtual unserialize : state_flags_t -> in_channel -> IO.input -> unit

  (** Serialize a memblock file to output channel *)
  method virtual serialize : unit IO.output -> string -> unit

end

(** Class for state interface *)
class state_interface : 
  state_header_t -> 
  in_channel -> 
  IO.input -> 
  userRegs option -> 
  memblock list ->
object
  (** [state#version] returns the version of the state file *)
  method version : int

  (** [state#version] returns the version of the state file *)
  method flags : state_flags_t 

  (** [state#blocks] returns the list of memory blocks in the state file *)
  method blocks : memblock list

  (** [state#num_blocks] returns the number of blocks in the state file O(1) *)
  method num_blocks : int

  (** [state#cleanup] Cleans the interface. Use close_state instead *)
  method cleanup : unit

  (** [state#regs] returns a register structure 
      Raises Registers_unavailable if the state file has no register info *)
  method regs : userRegs

  (** [state#exists addr] returns true if the given address [addr] 
    is part of one of the blocks in the state file *)
  method exists : Libasmir.address_t -> bool

  (** [state#get_char addr] returns the char value at address [addr] *)
  method get_char : Libasmir.address_t -> char

  (** [state#get_byte addr] returns the byte value at address [addr] *)
  method get_byte : Libasmir.address_t -> int

  (** [state#get_short addr] returns the short value at address [addr] 
      If [big_endian] is true, it assumes values stored in big-endian, 
      default is little-endian *)
  method get_short : ?big_endian:bool -> Libasmir.address_t -> int

  (** [state#get_word addr] returns the word value at address [addr]
      If [big_endian] is true, it assumes values stored in big-endian, 
      default is little-endian *)
  method get_word : ?big_endian:bool -> Libasmir.address_t -> int32

  (** [state#get_long addr] returns the long value at address [addr]
      If [big_endian] is true, it assumes values stored in big-endian, 
      default is little-endian *)
  method get_long : ?big_endian:bool -> Libasmir.address_t -> int64

  (** [state#get_float addr] returns the single-precision (32-bit) float at 
      address [addr] as a double precision float. 
      If [big_endian] is true, it assumes values stored in big-endian,
      default is little-endian *)
  method get_float : ?big_endian:bool -> Libasmir.address_t -> float

  (** [state#get_double addr] returns the double-precision (64-bit) double at
      address [addr].
      If [big_endian] is true, it assumes values stored in big-endian,
      default is little-endian *)
  method get_double : ?big_endian:bool -> Libasmir.address_t -> float

  (* Get an array of values at given address with given size *)
  (** [state#get_array addr size] reads the range from [addr] to [addr+size-1] 
      and returns an array of integers. *)
  method get_array : Libasmir.address_t -> int -> int array

  (** [state#get_string addr size] returns the string at address [addr]
      of length [size]. *)
  method get_string : Libasmir.address_t -> int -> string

  (** [state#get_ascii_string addr] returns the string starting at 
      address [addr] until a null character is found *)
  method get_ascii_string : Libasmir.address_t -> string

  (** [state#get_wide_string addr] returns the wide string starting at 
      address [addr] until a null character is found *)
  method get_wide_string : Libasmir.address_t -> string

  (** [state#get_memrange start end] extracts the values for all memory 
      addresses in the range from [start] to [end] (inclusive) 
      from the state file.
      Returns a list of pairs (address,byte_value). *)
  method get_memrange : Libasmir.address_t -> Libasmir.address_t -> 
    (Libasmir.address_t*char) list

  (** [state#range_inits range_l memvar] returns a Vine statement list with 
      memory initializers for all memory locations in all the ranges 
      specified by [range_l], where each range is: (start,end) 
      [memvar] is the memory variable used in the initializers 
      Note that this method does not use the taint information at all, 
      thus all initializers are concrete *)
  method range_inits : (int64*int64) list -> Vine.var -> Vine.stmt list

  (** [state#iter_range f first_addr last_addr] 
      applies function [f] to all pairs (address,raw byte) in the interval from
      [first_addr] to [last_addr] (inclusive).
      If the content of some addresses in the range are missing in 
      the state file, they are skipped, 
      thus [f] is not called on those addresses. *)
  method iter_range : (Libasmir.address_t -> char -> unit) ->
    Libasmir.address_t -> Libasmir.address_t -> unit

  (** [state#iter f first_addr last_addr] 
      applies function [f] to all pairs (address,raw byte) in the 
      state file. *)
  method iter : (Libasmir.address_t -> char -> unit) -> unit

  (** [state#write_range ?fill_char oc first_addr last_addr] 
      writes the raw bytes in the interval from [first_addr] to [last_addr] 
      (inclusive) to the given output channel [oc].
      If some bytes are missing in the state file, 
      they are replaced by [fill_char] *)
  method write_range : ?fill_char : char -> out_channel -> 
    Libasmir.address_t -> Libasmir.address_t -> unit

end

(** Get the start address of the memory page containing the given address *)
val page_start : ?page_size : int64 -> Libasmir.address_t -> Libasmir.address_t

(** Get the end address of the memory page containing the given address *)
val page_end : ?page_size : int64 -> Libasmir.address_t -> Libasmir.address_t

(** Get list of pages that comprise a range *)
val get_page_list : ?page_size : int64 -> Libasmir.address_t -> 
      Libasmir.address_t -> Libasmir.address_t list

(** Count number of bits set in a int64 *)
val hamming_weight64 : int64 -> int

(** [print_block oc blk] prints information on [blk] to given output
    channel [oc] *)
val print_block : ?print_taint : bool -> ?print_pos : bool -> out_channel -> 
      memblock -> unit

(** [print_flags oc flags] prints the flags [flags] to given output
    channel [oc] *)
val print_flags : out_channel -> state_flags_t -> unit

(** [print_regs oc regs] prints register values [regs] to given output
    channel [oc] *)
val print_regs : out_channel -> userRegs -> unit

(** [open_state filename] opens the given state file [filename], 
    returning the state inferface
    Raises Not_found, Unknown_state_version *)
val open_state : string -> state_interface

(** [close_state state] closes a state interface [state] 
    To be called when done using the state_interface *)
val close_state : state_interface -> unit

(** [add_range_inits_to_prog prog range_l memvar state] adds Vine memory 
    initializers to given program [prog] for the memory ranges specified 
    by [range_l] in the state interface [state] 
    using the memory variable [memvar].
    Returns an updated Vine program with the memory initializers *)
val add_range_inits_to_prog : Vine.program -> (int64*int64) list -> 
  Vine.var -> state_interface -> Vine.program

(** [generate_range_inits filename range_l memvar] generates Vine memory 
    initializers for the memory ranges specified 
    by [range_l] in the state file [filename] 
    using the memory variable [memvar].
    Returns the memory initializers as a list of Vine statements *)
val generate_range_inits : string -> (int64*int64) list -> Vine.var -> 
  Vine.stmt list

(** [unserialize_state_header ioc] reads a state_header from the
    IO channel [ioc] *)
val unserialize_state_header : in_channel -> IO.input -> state_header_t

(** [serialize_state_header ioc header] writes a state_header to the 
    IO channel [ioc] 
    Raises Unavailable_in_this_version for versions < 30 *)
val serialize_state_header : unit IO.output -> state_header_t -> unit

(** [unserialize_state_registers ioc] reads the register structure 
    from the [ioc] IO channel *)
val unserialize_state_registers : IO.input -> userRegs

(** [serialize_state_registers ioc regs] writes the register structure [regs] 
    to the [ioc] IO channel *)
val serialize_state_registers : unit IO.output -> userRegs -> unit


